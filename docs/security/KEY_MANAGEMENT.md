# Key Management — Career Engine Core

## Purpose of This Document

This document defines **how cryptographic keys are created, derived, used,
rotated, and destroyed** within the Career Engine.

It answers:
- What types of keys exist
- How keys are derived
- How keys may be used
- How long keys may live
- How keys must be destroyed
- What practices are forbidden

If any implementation violates these rules, it is insecure.

---

## Key Management Philosophy

Keys are **capabilities**, not data.

A key grants power.  
Therefore:
- Keys must be minimal
- Keys must be short-lived where possible
- Keys must be scoped to purpose
- Keys must never be exposed

Key management errors are catastrophic failures.

---

## Key Types (AUTHORITATIVE)

The engine recognizes **four key categories** only.

### 1. Root Secret (External)

**Description**
- Originates outside the engine
- Provided by the caller or OS mechanisms
- Used only for derivation

**Rules**
- Never generated by the engine
- Never stored by the engine
- Never logged
- Never reused directly

Examples:
- OS-protected secret
- User-supplied master secret (handled externally)

---

### 2. Master Key (Derived)

**Description**
- Derived from the root secret
- Used only to derive sub-keys

**Rules**
- Must be derived using Argon2id
- Must exist in memory only
- Must never be persisted
- Must be wiped immediately after use

---

### 3. Sub-Keys (Purpose-Scoped)

Examples:
- Storage encryption key
- Metadata encryption key
- Token encryption key

**Rules**
- One key per purpose
- No cross-purpose reuse
- Derived from master key
- Used only within security module

---

### 4. Ephemeral Session Keys

**Description**
- Short-lived keys for transient operations

**Rules**
- Generated via CSPRNG
- Never persisted
- Destroyed immediately after use

---

## Key Hierarchy (MANDATORY)

[Root Secret]
↓
Argon2id KDF
↓
[Master Key]
↓

↓ ↓ ↓
[Storage] [Metadata] [Token]
Key Key Key


Violating this hierarchy is forbidden.

---

## Key Derivation Rules

- Argon2id is mandatory
- Parameters must be fixed and documented
- Memory-hard configuration required
- No adaptive or dynamic parameters

Key derivation must be:
- Deterministic
- Auditable
- Reproducible

---

## Key Lifetime Rules

| Key Type        | Lifetime                |
|-----------------|-------------------------|
| Root Secret     | External / managed by caller |
| Master Key      | In-memory only          |
| Sub-Keys        | In-memory only          |
| Session Keys    | Single operation        |

Persisted keys are forbidden unless encrypted
and explicitly approved.

---

## Key Usage Rules

Keys may:
- Encrypt
- Decrypt
- Authenticate data

Keys must NOT:
- Be serialized
- Be copied unnecessarily
- Be shared across threads unsafely
- Be exposed via APIs

---

## Key Rotation Policy

The engine must support **key rotation** by:

- Re-deriving keys from a new root secret
- Re-encrypting persisted data
- Invalidating old keys immediately

Rotation must be:
- Explicit
- Caller-initiated
- Atomic where possible

Silent rotation is forbidden.

---

## Key Destruction Rules

Keys must be destroyed by:
- Explicit memory zeroization
- Immediate scope exit
- RAII-based cleanup

Relying on garbage collection or OS cleanup
is insufficient.

---

## Failure Handling

If key operations fail:
- Fail closed
- Abort the operation
- Prevent persistence
- Surface explicit error

Fallback to weaker keys or plaintext is forbidden.

---

## Forbidden Practices (ABSOLUTE)

The following are strictly forbidden:

- Hardcoded keys
- Static global keys
- Reusing keys across purposes
- Logging key material
- Returning keys from APIs
- Passing keys through non-secure memory
- Copying keys without justification

Any occurrence is a security defect.

---

## Testing Requirements

Key management must be tested for:
- Correct derivation
- Proper isolation
- Memory zeroization
- Rotation correctness
- Failure safety

Tests must never expose real key material.

---

## LLM-Specific Rules

AI coding assistants must:
- Never invent key schemes
- Never simplify key hierarchy
- Never reuse keys across purposes
- Prefer generating interfaces over implementations

If unsure, generate **no key code at all**.

---

## Final Key Management Rule

Keys protect user careers.

A broken key policy is worse than no feature.

If a feature cannot comply with this document,
the feature must not be implemented.
